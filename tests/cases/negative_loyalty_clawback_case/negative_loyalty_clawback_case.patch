diff --git a/src/loyalty.py b/src/loyalty.py
index 3a56d38..f0a1d8d 100644
--- a/src/loyalty.py
+++ b/src/loyalty.py
@@ -19,6 +19,11 @@ class LoyaltyService:
         # Convert points to a fixed monetary value.
         return round(points * 0.01, 2)
 
+    def restore(self, account_id: str, points: int) -> None:
+        if points <= 0:
+            return
+        self._balances[account_id] = self._balances.get(account_id, 0) + points
+
     def clawback(self, account_id: str, points: int) -> None:
         # Remove points when an order is refunded or fails after accrual.
         if points <= 0:
diff --git a/src/order_service.py b/src/order_service.py
index 6d9b38d..12c33eb 100644
--- a/src/order_service.py
+++ b/src/order_service.py
@@ -69,10 +69,12 @@ class OrderService:
         if not self._inventory.has_enough(order.sku, required):
             return OrderResult(status="insufficient_stock", reason="not_enough_inventory")
 
         loyalty_credit = None
+        redeemed_points = 0
         if order.loyalty_points_to_apply:
             try:
-                loyalty_credit = self._loyalty.redeem(order.account_id, order.loyalty_points_to_apply)
+                redeemed_points = order.loyalty_points_to_apply
+                loyalty_credit = self._loyalty.redeem(order.account_id, redeemed_points)
             except Exception as exc:
                 return OrderResult(status="loyalty_failed", reason=str(exc))
 
@@ -86,15 +88,21 @@ class OrderService:
         )
 
         risk = self._fraud.score(order_total=pricing.total, region=order.region)
         if risk.is_blocked:
+            if redeemed_points:
+                self._loyalty.restore(order.account_id, redeemed_points)
             self._audit.log("order_blocked", order.account_id, order.sku, risk.reason or "blocked")
             return OrderResult(status="blocked", pricing=pricing, reason=risk.reason)
         if risk.needs_review:
+            if redeemed_points:
+                self._loyalty.restore(order.account_id, redeemed_points)
             self._audit.log("order_review", order.account_id, order.sku, risk.reason or "review")
             return OrderResult(status="manual_review", pricing=pricing, reason=risk.reason)
 
         try:
             self._payment_gateway.charge(order.account_id, pricing.total)
         except Exception as exc:
+            if redeemed_points:
+                self._loyalty.restore(order.account_id, redeemed_points)
             self._audit.log("payment_failed", order.account_id, order.sku, str(exc))
             return OrderResult(status="payment_failed", pricing=pricing, reason=str(exc))
